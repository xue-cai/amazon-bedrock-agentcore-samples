#!/usr/bin/env python3
"""
Create Cognito users and obtain OAuth tokens for the AgentCore demo.

Usage:
    # Create a user (prompts for email and password interactively)
    python scripts/cognito-user.py --create

    # Login and print the export command
    python scripts/cognito-user.py --login

    # Login and output only the export line (for eval)
    eval $(python scripts/cognito-user.py --login --export)

    # Logout current session (to switch users)
    python scripts/cognito-user.py --logout
"""

import argparse
import base64
import getpass
import hashlib
import http.server
import json
import pathlib
import secrets
import subprocess
import sys
import urllib.parse
import webbrowser
from http.client import HTTPSConnection

try:
    import boto3
except ImportError:
    boto3 = None

# ---------------------------------------------------------------------------
# Configuration — loaded from cdk-outputs.json (generated by scripts/deploy.sh)
# ---------------------------------------------------------------------------
REDIRECT_URI = "http://localhost:3000/callback"
DEFAULT_GROUP = "standard"
SCOPES = [
    "openid",
    "email",
    "supportAgentDemo-api/runtime:invoke",
    "supportAgentDemo-api/gateway:invoke",
]

_CDK_OUTPUTS_FILE = pathlib.Path(__file__).resolve().parent.parent / "cdk-outputs.json"
_CDK_STACK_KEY = "supportAgentDemo-AgentCoreStack"


def _load_config():
    """Load deployment-specific config from cdk-outputs.json."""
    if not _CDK_OUTPUTS_FILE.exists():
        print(
            f"Error: {_CDK_OUTPUTS_FILE} not found.\n"
            "Run  scripts/deploy.sh  first to deploy the stack.",
            file=sys.stderr,
        )
        sys.exit(1)

    with open(_CDK_OUTPUTS_FILE) as f:
        outputs = json.load(f)

    stack = outputs.get(_CDK_STACK_KEY, {})
    missing = [
        k
        for k in ("UserPoolId", "ClientId", "CognitoDomain", "Region")
        if k not in stack
    ]
    if missing:
        print(
            f"Error: cdk-outputs.json is missing keys: {', '.join(missing)}\n"
            "Re-run  scripts/deploy.sh  to regenerate it.",
            file=sys.stderr,
        )
        sys.exit(1)

    return (
        stack["UserPoolId"],
        stack["ClientId"],
        stack["CognitoDomain"],
        stack["Region"],
    )


USER_POOL_ID, CLIENT_ID, COGNITO_DOMAIN, REGION = _load_config()

# ---------------------------------------------------------------------------
# User creation
# ---------------------------------------------------------------------------


def create_user(email, group=DEFAULT_GROUP, password=None):
    """Create a Cognito user, set their password, and add to a group."""
    if boto3 is None:
        print(
            "Error: boto3 is required for --create. Install it: uv pip install boto3",
            file=sys.stderr,
        )
        sys.exit(1)

    client = boto3.client("cognito-idp", region_name=REGION)

    # Create the user
    try:
        client.admin_create_user(
            UserPoolId=USER_POOL_ID,
            Username=email,
            UserAttributes=[
                {"Name": "email", "Value": email},
                {"Name": "email_verified", "Value": "true"},
                {"Name": "custom:refund_tier", "Value": group},
            ],
            MessageAction="SUPPRESS",  # Don't send welcome email
        )
        print(f"Created user: {email}")
    except client.exceptions.UsernameExistsException:
        print(f"User already exists: {email}")

    # Set a permanent password (skip FORCE_CHANGE_PASSWORD state)
    client.admin_set_user_password(
        UserPoolId=USER_POOL_ID,
        Username=email,
        Password=password,
        Permanent=True,
    )
    print(f"Password set for: {email}")

    # Add user to group
    try:
        client.admin_add_user_to_group(
            UserPoolId=USER_POOL_ID,
            Username=email,
            GroupName=group,
        )
        print(f"Added to group: {group}")
    except Exception as e:
        print(f"Warning: could not add to group '{group}': {e}", file=sys.stderr)

    print("\nUser ready. Login with:")
    print("  eval $(python scripts/cognito-user.py --login --export)")


# ---------------------------------------------------------------------------
# OAuth login (PKCE flow)
# ---------------------------------------------------------------------------


def copy_to_clipboard(text):
    """Copy text to clipboard (macOS/Linux)."""
    try:
        subprocess.run(["pbcopy"], input=text.encode(), check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        try:
            subprocess.run(
                ["xclip", "-selection", "clipboard"], input=text.encode(), check=True
            )
            return True
        except (subprocess.CalledProcessError, FileNotFoundError):
            return False


def generate_pkce():
    """Generate PKCE code verifier and challenge."""
    code_verifier = secrets.token_urlsafe(32)
    digest = hashlib.sha256(code_verifier.encode()).digest()
    code_challenge = base64.urlsafe_b64encode(digest).rstrip(b"=").decode()
    return code_verifier, code_challenge


def build_auth_url(code_challenge, username=None):
    """Build Cognito authorization URL."""
    params = {
        "response_type": "code",
        "client_id": CLIENT_ID,
        "redirect_uri": REDIRECT_URI,
        "scope": " ".join(SCOPES),
        "code_challenge_method": "S256",
        "code_challenge": code_challenge,
    }
    if username:
        params["login_hint"] = username
    query = urllib.parse.urlencode(params)
    return f"https://{COGNITO_DOMAIN}/oauth2/authorize?{query}"


def exchange_code_for_tokens(code, code_verifier):
    """Exchange authorization code for tokens."""
    body = urllib.parse.urlencode(
        {
            "grant_type": "authorization_code",
            "client_id": CLIENT_ID,
            "code": code,
            "redirect_uri": REDIRECT_URI,
            "code_verifier": code_verifier,
        }
    )
    conn = HTTPSConnection(COGNITO_DOMAIN)
    conn.request(
        "POST",
        "/oauth2/token",
        body,
        {"Content-Type": "application/x-www-form-urlencoded"},
    )
    response = conn.getresponse()
    data = json.loads(response.read().decode())
    conn.close()
    return data


def decode_jwt_payload(token):
    """Decode JWT payload for display."""
    try:
        payload = token.split(".")[1]
        padding = 4 - len(payload) % 4
        if padding != 4:
            payload += "=" * padding
        return json.loads(base64.urlsafe_b64decode(payload))
    except Exception:
        return {}


class CallbackHandler(http.server.BaseHTTPRequestHandler):
    """HTTP handler to capture OAuth callback."""

    code = None
    error = None

    def log_message(self, format, *args):
        pass

    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        if parsed.path == "/logout":
            self.send_response(200)
            self.send_header("Content-Type", "text/html")
            self.end_headers()
            self.wfile.write(b"""
                <html><body style="font-family: sans-serif; text-align: center; padding: 50px;">
                <h1>Logged Out</h1>
                <p>You can close this window.</p>
                <script>window.close();</script>
                </body></html>
            """)
        elif parsed.path == "/callback":
            params = urllib.parse.parse_qs(parsed.query)
            if "code" in params:
                CallbackHandler.code = params["code"][0]
                self.send_response(200)
                self.send_header("Content-Type", "text/html")
                self.end_headers()
                self.wfile.write(b"""
                    <html><body style="font-family: sans-serif; text-align: center; padding: 50px;">
                    <h1>Authorization Successful</h1>
                    <p>You can close this window and return to the terminal.</p>
                    </body></html>
                """)
            elif "error" in params:
                CallbackHandler.error = params.get(
                    "error_description", params["error"]
                )[0]
                self.send_response(400)
                self.send_header("Content-Type", "text/html")
                self.end_headers()
                self.wfile.write(
                    f"""
                    <html><body style="font-family: sans-serif; text-align: center; padding: 50px;">
                    <h1>Authorization Failed</h1>
                    <p>{CallbackHandler.error}</p>
                    </body></html>
                """.encode()
                )
        else:
            self.send_response(404)
            self.end_headers()


def run_callback_server(port=3000):
    """Start local HTTP server to capture callback."""
    server = http.server.HTTPServer(("localhost", port), CallbackHandler)
    server.timeout = 120
    server.handle_request()
    server.server_close()
    return CallbackHandler.code, CallbackHandler.error


def do_logout():
    """Logout the current Cognito session."""
    params = {"client_id": CLIENT_ID, "logout_uri": "http://localhost:3000/logout"}
    logout_url = f"https://{COGNITO_DOMAIN}/logout?{urllib.parse.urlencode(params)}"

    print("Logging out previous session...", file=sys.stderr)
    server = http.server.HTTPServer(("localhost", 3000), CallbackHandler)
    server.timeout = 30
    webbrowser.open(logout_url)
    server.handle_request()
    server.server_close()
    print("Logged out.\n", file=sys.stderr)


def do_login(export_mode=False):
    """Run OAuth PKCE login flow. In export mode, print only the export line to stdout."""
    code_verifier, code_challenge = generate_pkce()
    auth_url = build_auth_url(code_challenge)

    if not export_mode:
        print("Opening browser for authentication...")
    else:
        print("Opening browser for authentication...", file=sys.stderr)

    webbrowser.open(auth_url)

    if not export_mode:
        print("Waiting for callback on http://localhost:3000/callback ...")
    else:
        print("Waiting for callback...", file=sys.stderr)

    code, error = run_callback_server()

    if error:
        print(f"Error: {error}", file=sys.stderr)
        sys.exit(1)
    if not code:
        print("Timeout waiting for authorization", file=sys.stderr)
        sys.exit(1)

    tokens = exchange_code_for_tokens(code, code_verifier)

    if "error" in tokens:
        print(
            f"Token error: {tokens.get('error_description', tokens['error'])}",
            file=sys.stderr,
        )
        sys.exit(1)

    access_token = tokens.get("access_token", "")

    if export_mode:
        # Only the export line goes to stdout (for eval); status goes to stderr
        print(f'export BEDROCK_AGENTCORE_BEARER_TOKEN="{access_token}"')
        print(
            "Login successful. BEDROCK_AGENTCORE_BEARER_TOKEN is now set.",
            file=sys.stderr,
        )
    else:
        id_token = tokens.get("id_token", "")
        access_claims = decode_jwt_payload(access_token)
        id_claims = decode_jwt_payload(id_token)

        print("\n" + "=" * 60)
        print("TOKENS RECEIVED")
        print("=" * 60)
        print(f"\n  email:  {id_claims.get('email', 'N/A')}")
        print(f"  groups: {access_claims.get('cognito:groups', 'N/A')}")
        print(f"  scope:  {access_claims.get('scope', 'N/A')}")
        print(f"  exp:    {access_claims.get('exp', 'N/A')}")
        print("\n--- Usage ---")
        print(f'export BEDROCK_AGENTCORE_BEARER_TOKEN="{access_token}"')
        print('\nagentcore invoke \'{"prompt": "Who am I?"}\'\n')


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


def main():
    parser = argparse.ArgumentParser(
        description="Create Cognito users and get OAuth tokens for the AgentCore demo.",
    )
    parser.add_argument(
        "--create",
        action="store_true",
        help="Create a user in Cognito (prompts for email and password)",
    )
    parser.add_argument(
        "--group",
        default=DEFAULT_GROUP,
        choices=["standard", "premium", "vip"],
        help="Cognito group to assign (default: standard)",
    )
    parser.add_argument(
        "--login", action="store_true", help="Login via browser and get a bearer token"
    )
    parser.add_argument(
        "--export",
        action="store_true",
        help="With --login, output only the export line (for eval)",
    )
    parser.add_argument(
        "--logout", action="store_true", help="Logout current Cognito session"
    )
    args = parser.parse_args()

    if not any([args.create, args.login, args.logout]):
        parser.print_help()
        sys.exit(1)

    if args.create:
        print("Use an email matching the backend mock data:")
        print("  John Doe  → john@example.com")
        print("  Jane Smith → jane@example.com")
        print()
        email = input("Email: ").strip()
        if not email:
            print("Error: email is required", file=sys.stderr)
            sys.exit(1)
        password = getpass.getpass(
            "Password (must include uppercase, lowercase, number, and symbol): "
        )
        if not password:
            print("Error: password is required", file=sys.stderr)
            sys.exit(1)
        create_user(email, group=args.group, password=password)

    if args.logout:
        do_logout()

    if args.login:
        do_login(export_mode=args.export)


if __name__ == "__main__":
    main()
